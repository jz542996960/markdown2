# Thread



## 一. 线程的几种状态

   1. 新建状态 （通过new 关键字初始话一个线程）

   2. 就绪状态（调用线程的start方法，线程就进入就绪状态，要等待jvm调度器的调度）

   3. 运行状态 （获取大cup资源，开始执行run()方法，可以变为阻塞，就绪，死亡状态）

   4. 阻塞状态

        如果一个线程执行了sleep，suspend 等方法，失去所占用的资源，改线程就进入到阻塞状态，在睡眠时间已到或者获得了设备资源后就可以重新进去就绪状态。 分为三种：

         - 等待阻塞： 运行状态的线程执行了wait 方法，进入到阻塞状态
         - 同步阻塞： 线程在活动synchronized同步锁失败
         - 其他阻塞：通过调用线程的sleep 或者join方法，线程就会进去阻塞状态。当sleep 状态超时，join等待线程终止或超时，或者I/0处理完毕，线程进去就绪状态。

   5. 死亡状态：  运行的线程完成任务 return。或者其他终止条件发生，线程就进去死亡状态。

      

      

## 二. 线程的wait() 和notify()

​        由于等待一个锁定线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不需要锁的时候及时释放锁是很重要的。

 **1.在以下情况下，持有锁的线程会释放锁：**

  1. 执行完同步代码块。
  2. 在执行同步代码块的过程中，遇到异常而导致线程终止。

3. 在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池。

   

 **2. 只要持有锁的线程还没有执行完同步代码块，就不会释放锁。因此在以下情况下，线程不会释放锁：**

  1. 在执行同步代码块的过程中，执行了Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。
  2. 行了Thread.yield()方法，当前线程放弃CPU，但不会释放锁。
  3. 在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类suspend()方法已经被废弃。

> 避免死锁的一个通用的经验法则是：当几个线程都要访问共享资源A、B和C时，保证使每个线程都按照同样的顺序去访问他们，比如都先访问A，再访问B和C。



​     java.lang.Object类中提供了两个用于线程通信的方法：wait()和notify()。需要注意到是，<font color ="#A52A2A ">wait()方法必须放在一个循环中，因为在多线程环境中，共享对象的状态随时可能改变。当一个在对象等待池中的线程被唤醒后，并不一定立即恢复运行，等到这个线程获得了锁及CPU才能继续运行，又可能此时对象的状态已经发生了变化</font>。

  1. 在执行同步代码块的过程中，调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) {...} 代码段内。

 2. 调用obj.wait()后，线程A就释放了obj的锁，否则线程B无法获得obj锁，也就无法在synchronized(obj) {...} 代码段内唤醒A。

3. 当obj.wait()方法返回后，线程A需要再次获得obj锁，才能继续执行。

 4.   如果A1,A2,A3都在obj.wait()，则B调用obj.notify()只能唤醒A1,A2,A3中的一个（具体哪一个由JVM决定）。

5.  obj.notifyAll()则能全部唤醒A1,A2,A3，但是要继续执行obj.wait()的下一条语句，必须获得obj锁，因此，A1,A2,A3只有一个有机会获得锁继续执行，例如A1，其余的需要等待A1释放obj锁之后才能继续执行。

6.  当B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1,A2,A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2,A3中的一个才有机会获得锁继续执行。



## 三. wait()/sleep()的区别

　　前面讲了wait/notify机制，Thread还有一个sleep()静态方法，它也能使线程暂停一段时间。sleep与wait的不同点是：sleep并不释放锁，并且sleep的暂停和wait暂停是不一样的。obj.wait会使线程进入obj对象的等待集合中并等待唤醒。
　　
　　但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。
　　
　　如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。
　　
　　需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()后，就会立刻抛出InterruptedException。

​       















 





